Waveshare ESP32-S3-Touch-LCD-4.3B: A Comprehensive Technical Analysis for AI-Assisted System Development1.0 System Architecture and Executive Summary1.1 OverviewThis report provides an exhaustive technical analysis of the Waveshare ESP32-S3-Touch-LCD-4.3B development board, a high-performance Human-Machine Interface (HMI) platform engineered for demanding graphical applications.1 The system is centered around the powerful Espressif ESP32-S3 System-on-Chip (SoC), which features a 240 MHz Xtensa® 32-bit LX7 dual-core processor, integrated Wi-Fi and Bluetooth 5 (LE) connectivity, 16MB of Quad I/O (QIO) flash memory, and a crucial 8MB of high-bandwidth Octal (OPI) PSRAM.1 The board's primary feature is a vibrant 4.3-inch, 800×480 pixel In-Plane Switching (IPS) display, driven by a 24-bit parallel RGB interface. This high-throughput interface, coupled with the processing power of the ESP32-S3, enables fluid, high-frame-rate graphical user interfaces suitable for industrial control, smart home automation, and other IoT applications.3 This analysis is framed within the context of developing a "Commercial Freezer Controller," a project that leverages the board's full capabilities for real-time monitoring and control.1.2 The Core Technical Challenge: The Display-Expander DependencyAn in-depth architectural review reveals that the ESP32-S3-Touch-LCD-4.3B is not a conventional development board but a highly integrated, application-specific platform with non-obvious hardware interdependencies. The most significant of these is the method used to control the display's essential functions. The ST7262 display controller's critical control signals—specifically the hardware Reset (LCD_RST) and Backlight (DISPLAY_BL_PIN)—are not connected to the ESP32-S3's General-Purpose Input/Output (GPIO) pins as is standard practice. Instead, they are physically routed through a WCH CH422G I/O expander chip, which resides on the I²C bus.3This design choice, likely made to conserve the ESP32-S3's limited GPIO pins after allocating 28 pins to the parallel display, creates a fundamental architectural constraint. It mandates a non-standard, multi-step initialization sequence that renders common display libraries, such as TFT_eSPI or even Espressif's generic ESP_Panel library, completely unusable out of the box.3 These libraries are architected with the assumption of direct GPIO control for reset and backlight toggling. On this board, any attempt to perform a digitalWrite() to a virtual reset pin will fail, as no such physical connection to the ESP32 exists. The entire display initialization process is contingent upon first communicating with the CH422G expander over I²C to perform these essential hardware operations.8 The result is a tightly coupled system where the display driver is inextricably dependent on the I/O expander driver.1.3 The Immutable Software StackAs a direct and unavoidable consequence of this hardware architecture, the "Commercial Freezer Controller" project is locked to a specific, non-updatable, and fragile set of local libraries. The currently stable and functional build relies on a precise pairing of ESP32_Display_Panel@1.0.0 and ESP32_IO_Expander@1.0.1.3 These specific versions contain the necessary logic to handle the complex, ordered initialization sequence.Attempts to update these libraries to more recent versions from the official repositories will result in compilation failure. Analysis of the library evolution and community-reported issues confirms that significant breaking changes were introduced in later versions, including a major refactoring to use C++ namespaces and a change in header file names (e.g., from ESP_IOExpander.h to esp_io_expander.hpp).10 The local version of ESP32_Display_Panel used in the successful build depends on the older header file name, creating a fatal dependency conflict if the I/O expander library is updated. Therefore, any AI-assisted development must operate strictly within the confines of the existing, proven library APIs and must not attempt to update, substitute, or modify this critical pair.1.4 Report ObjectiveThe primary objective of this document is to provide a complete, unambiguous, and deeply technical blueprint of the Waveshare ESP32-S3-Touch-LCD-4.3B's hardware, firmware, and critical software dependencies as they exist in the current working build. This report is meticulously designed to serve as the definitive, single-source-of-truth prompt for an advanced AI development assistant. By thoroughly documenting the system's constraints and providing clear, actionable directives, this report will enable the AI to contribute effectively to the project's completion without violating the core architectural guardrails that ensure its stability and functionality.2.0 Hardware Subsystem Deep Dive2.1 Core Processing Unit: ESP32-S3-WROOM-1-N16R8The computational core of the development board is the ESP32-S3-WROOM-1-N16R8 module from Espressif Systems.1 This powerful and versatile module is specifically designed for AIoT applications that demand robust processing and connectivity.Processor: The module is equipped with a high-performance Xtensa® 32-bit LX7 dual-core processor, with each core capable of running at a main frequency of up to 240 MHz.2 This dual-core architecture is fundamental to the project's design, allowing for the strategic separation of real-time tasks (like display rendering) from application-level logic to ensure a responsive user interface, as detailed in Section 4.3.3On-Chip Memory: The ESP32-S3 SoC integrates 512KB of SRAM and 384KB of ROM, which are used for critical real-time operations, task stacks, and the FreeRTOS kernel.1External Flash Memory: The module includes 16MB of external Quad I/O (QIO) flash memory.1 This high-speed flash is used for storing the application firmware, static assets, and potentially a filesystem. The project's platformio.ini correctly configures the build system to utilize this full capacity with board_build.flash_mode = qio and board_build.flash_size = 16MB.3External PSRAM: A critical component for this HMI application is the module's 8MB of Octal (OPI) PSRAM.1 Octal PSRAM provides a significantly higher data bandwidth compared to Quad PSRAM. This high-speed memory is essential for storing the large graphics frame buffers required by the 800x480 display without overwhelming the ESP32-S3's limited internal SRAM. The build system is explicitly configured to leverage this high-performance mode via the board_build.psram_mode = octal flag in platformio.ini.3Connectivity: The module provides comprehensive wireless connectivity with support for 2.4GHz Wi-Fi (802.11 b/g/n) and Bluetooth 5 (LE), utilizing an onboard antenna.4The combination of a fast dual-core CPU and high-bandwidth Octal PSRAM is the key hardware enabler that makes driving a high-resolution parallel display at fluid frame rates a feasible endeavor on this microcontroller-based platform.2.2 Display Subsystem: 800x480 IPS with ST7262 ControllerThe visual centerpiece of the board is its 4.3-inch color display, a high-quality panel designed for excellent visual performance in HMI applications.1Panel Specifications: The display is an In-Plane Switching (IPS) panel, which provides superior color accuracy and wide viewing angles of 160°.1 It features a native resolution of 800×480 pixels and supports a 65K color depth.1Display Interface: The board employs a 24-bit Parallel RGB (RGB888) interface to communicate between the ESP32-S3 and the display controller.1 This high-throughput interface is a significant departure from the more common SPI-based displays. It dedicates 24 separate GPIO lines for color data (8 for red, 8 for green, 8 for blue) and an additional 4 GPIO lines for timing and synchronization signals: Pixel Clock (PCLK), Data Enable (DE), Horizontal Sync (HSYNC), and Vertical Sync (VSYNC).3 This parallel architecture allows for the entire pixel data to be transferred simultaneously, enabling the high frame rates (60+ FPS) targeted by the project.3Display Controller: Sitronix ST7262: The display panel is driven by an ST7262 System-on-Chip (SoC) driver.3 An analysis of the ST7262 datasheet is critical to understanding the system's software requirements.14Initialization Sequence: The ST7262 datasheet specifies a mandatory power-on sequence. Critically, it requires a hardware reset pulse (toggling the GRB pin from high to low, then back to high) before the display can be enabled.14 As the GRB pin is connected to the CH422G I/O expander, this hardware requirement is the root cause of the system's primary software dependency, as detailed in Section 3.0.RGB Interface Timing: The datasheet provides precise timing parameters for the RGB interface, including the required frequencies and durations for PCLK, HSYNC, and VSYNC signals and their associated back/front porches.14 For an 800x480 display, the typical PCLK is 25 MHz. These timing values are hardcoded within the custom ESP32_Display_Panel@1.0.0 library to match the hardware requirements.Command Registers: The ST7262 is configured via an I²C or 3-wire serial interface after power-on. Key commands used by the driver include GRB, DISP CONTROL (10h) to enable the display output after reset and DISPLAY MODE SETTING (19h) to configure parameters like scan direction (VDIR, HDIR).14 The ESP32_Display_Panel library encapsulates the logic for sending these initialization commands in the correct order.2.3 I/O Expansion & Control Subsystem: The CH422GThe WCH CH422G chip is the unassuming linchpin of the entire display system. While marketed as a simple I/O expander, on this board, it serves a mission-critical role in the display's fundamental operation.3Function: The CH422G is an I²C-based I/O expander that provides 8 bidirectional I/O pins and 4 general-purpose output pins.15 Its primary purpose on this board is to provide control over hardware lines for which there were no available ESP32-S3 GPIOs.I²C Interface and Protocol: The chip communicates over the same I²C bus as the touch controller and RTC (GPIO 8 for SDA, GPIO 9 for SCL).1 The project's working build confirms its fixed I²C address is 0x71.3 Analysis of the chip's Chinese datasheet reveals it does not use a simple, flat register map but rather a command-based protocol.15 A write operation consists of sending a start condition, a specific command byte, and a data byte. Forum discussions have reverse-engineered these commands into more accessible "register" addresses for practical use, such as 0x24 for mode setting and 0x38 for writing to the output pins.8 The ESP32_IO_Expander@1.0.1 library implements this specific command protocol.Critical Control Lines: The true significance of the CH422G is revealed by the functions it controls. The board's schematic and the project's documentation confirm that the CH422G's expanded I/O pins are hardwired to the following critical system functions 3:Display Reset (LCD_RST): Connected to an expander pin (e.g., EXIO0 or EXIO3 depending on board revision). This is the only way to perform the hardware reset required by the ST7262 controller.Display Backlight (DISPLAY_BL_PIN): The backlight's enable and PWM control signals are managed by expander pins. Without initializing the CH422G and setting these pins, the display will remain physically dark, even if the LCD controller is active.Touch Controller Reset (TOUCH_RST_PIN): The reset line for the GT911 touch controller is also routed through the expander.Micro SD Card Chip Select (SD_CS): The Chip Select line for the SD card slot is connected to an expander pin (EXIO4). This has significant performance implications, as every SD card transaction must be wrapped by I²C commands to the CH422G to assert and de-assert the CS line, introducing considerable overhead compared to a direct GPIO-based SPI implementation.Without a functional driver for the CH422G, the display cannot be reset, the backlight cannot be enabled, the touch controller cannot be initialized, and the SD card cannot be accessed. The system would be, for all practical purposes, non-functional.32.4 User Interface Peripherals: GT911 and PCF85063ATo complement the display, the board includes standard peripherals for user interaction and timekeeping, both communicating over the shared I²C bus.GT911 Capacitive Touch Controller:Functionality: The board uses a GOODIX GT911 controller to manage the 5-point capacitive touch overlay.1Interface: It connects to the ESP32-S3 via the I²C bus on GPIO 8 (SDA) and GPIO 9 (SCL).3 It uses a dedicated interrupt pin, GPIO 4, to efficiently signal to the host that a touch event has occurred and data is ready to be read, avoiding the need for constant polling.3I²C Address: The GT911 can have two possible I²C slave addresses (0xBA/0xBB or 0x28/0x29), which are typically configured during power-on initialization.17 The project documentation implies the driver handles this detection.Data Protocol: As detailed in its programming guide, reading touch data involves first writing the starting register address (0x814E for status and touch point data) and then initiating a read sequence.18 The status byte at 0x814E indicates if new data is available and how many touch points are active. This is followed by 8-byte data blocks for each active touch point, containing the track ID, X/Y coordinates, and touch area size.18PCF85063A Real-Time Clock:Functionality: The board includes a PCF85063A RTC from NXP to provide accurate, low-power timekeeping capabilities.3 This is essential for the freezer controller's data logging and for scheduling time-based events like defrost cycles.Interface: It is the third device on the shared I²C bus (GPIO 8/9) and uses the slave address 0x51.3Data Protocol: The RTC's registers are accessed via standard I²C read/write operations. The time and date information is stored in BCD format in registers 04h (Seconds) through 0Ah (Years). Alarm functions are configured in registers 0Bh through 0Fh.20 The project's application logic will interact with these registers to get timestamps and set wake-up alarms.3.0 The Critical Initialization Chain: A System-Defining DependencyThe unique hardware architecture of the Waveshare ESP32-S3-Touch-LCD-4.3B, specifically the delegation of primary display control to the CH422G I/O expander, imposes a rigid and non-negotiable software initialization sequence. Understanding this sequence is the single most important factor in successfully developing for this platform. Failure to adhere to this precise order of operations is the primary reason that standard, off-the-shelf display libraries are incompatible and will invariably fail to initialize the screen.3.1 The Problem with Standard LibrariesGeneric Arduino display libraries like the popular TFT_eSPI or even Espressif's own ESP_Panel library are architected around a common and logical assumption: that the display's fundamental control pins, such as Reset (RST) and Backlight (BL), are connected directly to the host microcontroller's GPIOs.3 Their initialization routines typically expect integer pin numbers for these functions and perform direct digital write operations to control them (e.g., digitalWrite(RST_PIN, LOW); delay(10); digitalWrite(RST_PIN, HIGH);).7On the Type B board, this assumption is false. The LCD_RST and backlight control lines are not physically connected to any ESP32-S3 GPIO pins; they are connected to the output pins of the CH422G expander.6 Consequently, when a standard library attempts to toggle the reset pin, it is performing a digital write on an unconnected processor pin, and the ST7262 display controller never receives the required hardware reset pulse specified in its datasheet.14 Similarly, commands to enable the backlight are sent to a non-existent connection. The result is a system that may compile and run code without error, but the display will remain uninitialized and dark, appearing "dead" to the user.33.2 The Mandatory "Type B" Initialization SequenceTo successfully bring the display online, the software must precisely mirror the physical dependency chain of the hardware. This involves a choreographed sequence of operations across multiple drivers and communication buses. The following ordered steps are mandatory and form the core logic of the project's working build.I²C Bus Initialization: The process must begin by initializing the ESP32's master I²C peripheral driver (I2C0) on GPIO pins 8 (SDA) and 9 (SCL). This bus is the shared communication backbone for the touch controller, the RTC, and, most importantly, the CH422G I/O expander.1I/O Expander Driver Initialization (ESP32_IO_Expander@1.0.1): Immediately following I²C bus setup, an instance of the CH422G driver from the ESP32_IO_Expander library must be created and initialized. This initialization targets the expander's fixed I²C slave address of 0x71.3 The library's init() or begin() function establishes communication with the chip.Expander Pin Configuration: Once communication with the CH422G is established, its internal registers must be configured. Specifically, the expander pins connected to the display's reset and backlight lines must be set to OUTPUT mode using the ESP32_IO_Expander library's API (e.g., expander->pinMode(pin, OUTPUT)).Display Hardware Reset via I/O Expander: With the reset pin configured as an output on the expander, the software must now send a sequence of I²C commands to the CH422G, instructing it to toggle the LCD_RST line. This sequence (e.g., write LOW, delay 10-20ms, write HIGH) generates the physical reset pulse on the ST7262's GRB pin, satisfying its power-on reset requirement.14 This is the most critical and non-standard step in the entire process.Parallel RGB Display Driver Initialization (ESP32_Display_Panel@1.0.0): Only after the ST7262 controller has been successfully hardware-reset can the ESP32_Display_Panel library be initialized. This library's initialization function performs the standard setup for the ESP32's LCD peripheral, configuring the 28 GPIOs for the parallel RGB interface, setting up DMA transfers from PSRAM, and sending the ST7262-specific initialization command sequence over its control interface to configure its internal registers (e.g., for display mode, scan direction, etc.).3Backlight Activation via I/O Expander: The final step is to make the display visible. This is achieved by sending another I²C command to the CH422G, this time instructing it to set the DISPLAY_BL_PIN high. This enables the backlight boost converter circuit, illuminating the now-active LCD panel.33.3 Visualizing the Dependency FlowThe interaction can be visualized as a multi-layered dependency chain:Application Code -> ESP32_Display_Panel Driver -> ESP32_IO_Expander Driver -> ESP32 I²C Driver -> Hardware Bus -> CH422G Chip -> Physical Reset/Backlight Pins -> ST7262 ControllerA failure at any point in this chain will prevent all subsequent steps from succeeding. A black screen on boot is therefore not necessarily a display driver failure; it is more likely a failure much earlier in the chain, such as an I²C communication error or an incorrect initialization of the CH422G expander. This diagnostic logic is essential for any troubleshooting or further development.4.0 Firmware and Software ArchitectureThe firmware for the "Commercial Freezer Controller" is built upon a carefully configured PlatformIO environment, a specific and immutable set of libraries, and a deliberate FreeRTOS tasking architecture designed to maximize performance and stability.4.1 Build Environment: PlatformIOThe project utilizes the PlatformIO IDE, with the core configuration defined in the platformio.ini file. This file is critical as it contains the specific flags and settings required to compile firmware that correctly targets the board's unique hardware capabilities.3A detailed analysis of the provided platformio.ini reveals the following key configurations:Platform & Board:platform = espressif32: Specifies the use of the Espressif IoT Development Framework.board = esp32s3box: This is a crucial selection. While not the exact board, the esp32s3box profile provides a baseline configuration that is compatible with the ESP32-S3's memory and peripheral layout. It correctly enables the necessary SoC features for the build process.framework = arduino: The project is built upon the Arduino core for ESP32, providing a familiar API while still allowing for low-level configuration.Hardware Configuration:board_build.flash_mode = qio: Configures the flash interface for Quad I/O mode at 80 MHz, matching the 16MB QIO flash chip.board_build.psram_mode = octal: This is one of the most critical settings. It enables the high-bandwidth Octal SPI interface for the 8MB PSRAM, which is essential for achieving high-speed graphics rendering.Build Flags (build_flags):PSRAM Enablement: A block of flags (-DBOARD_HAS_PSRAM, -DCONFIG_SPIRAM_SUPPORT=1, etc.) explicitly enables PSRAM support in the underlying ESP-IDF and forces the memory allocator (malloc) to utilize it. This makes the 8MB of PSRAM available to the application and libraries.LVGL Configuration: -DLV_CONF_INCLUDE_SIMPLE and -DLV_TICK_PERIOD_MS=5 configure the LVGL graphics library. The 5ms tick period corresponds to a 200Hz internal refresh rate, which helps ensure smooth animations.Hardware Pin Definitions: A series of -D flags are used to pass hardware pin definitions directly to the compiler. This hardcodes the pin numbers for the display timing signals (e.g., -DDISPLAY_DE_PIN=5), the I²C bus (-DTOUCH_SDA_PIN=8), and other peripherals. This practice ensures that the code is compiled with the correct, non-changeable pin assignments for the Type B board.4.2 The Immutable Library StackThe project's stability hinges on a precise combination of library versions. The interdependencies, particularly between the display and I/O expander drivers, are so tight that deviation leads to build failures or runtime errors.LibraryRequired VersionLocationRationale for Version LockStatusESP32_Display_Panel1.0.0Local lib/Contains the specific driver for the ST7262 controller and the hardcoded logic to interact with the CH422G expander. The public GitHub version lacks this specific Type B implementation logic.3ImmutableESP32_IO_Expander1.0.1Local lib/Provides the necessary driver for the CH422G chip. This specific version predates a major refactoring in the official library that introduced C++ namespaces and renamed the primary header file, making it incompatible with the local display driver.3Immutablelvgl8.3.11RegistryA known stable version for the ESP32-S3. Later versions (e.g., v8.4.x) are documented to have regressions related to font rendering on this specific platform, making an update risky.3Immutableesp-lib-utils0.1.2RegistryA dependency of the ESP32_IO_Expander@1.0.1 library, providing utility functions for logging and memory management. Minor version updates may be possible but are not recommended without extensive testing.3RestrictedDallasTemperatureLatestRegistryThis library for the DS18B20 sensors has a stable and mature API. Updates are generally safe and unlikely to cause conflicts.3UpdatableOneWireLatestRegistryThe underlying bus protocol library for DallasTemperature. It also has a stable API and can be safely updated.3UpdatableThe critical dependency conflict arises from changes made in the official ESP32_IO_Expander library after version 1.0.1. Newer versions refactored the code into a C++ namespace and changed the include directive from #include "ESP_IOExpander.h" to #include <esp_io_expander.hpp>.10 The project's local ESP32_Display_Panel@1.0.0 library, however, was built against the older version and contains the line #include "ESP_IOExpander.h". When the I/O expander library is updated, the compiler can no longer find the expected header file, leading to the fatal compilation error reported in community forums.11 This proves that the user's specific, older combination of local libraries is a mandatory and fragile pairing.4.3 FreeRTOS Dual-Core Tasking ModelThe firmware employs a sophisticated dual-core architecture using FreeRTOS to ensure that the demanding, real-time requirements of the user interface do not interfere with the application's control logic, and vice-versa.3Task NamePinned CorePriorityFunctiondisplayTaskCore 0configMAX_PRIORITIES - 1Highest priority; handles low-level display updates.touchTaskCore 0configMAX_PRIORITIES - 2Critical priority; processes touch input events.lvglTaskCore 0configMAX_PRIORITIES - 3High priority; handles LVGL rendering ticks.controlTaskCore 1tskIDLE_PRIORITY + 3Medium priority; executes freezer control logic.sensorTaskCore 1tskIDLE_PRIORITY + 2Low priority; handles periodic temperature readings.loggingTaskCore 1tskIDLE_PRIORITY + 1Background priority; performs data logging to SD card.This strategy dedicates Core 0 (the "Protocol" core in ESP-IDF terminology) exclusively to high-frequency, low-latency UI tasks. Pinning the display, touch, and LVGL tasks to this core with the highest priorities guarantees that UI rendering and responsiveness are shielded from any delays or heavy processing occurring in the application logic. Core 1 (the "Application" core) is responsible for all other system functions, such as sensor polling, control algorithms, and data logging, which can tolerate slightly higher latency.4.4 Strategic Memory AllocationThe system's memory management strategy is designed to make optimal use of both the fast internal SRAM and the large external PSRAM, ensuring that memory-intensive graphics do not starve the rest of the system.3Memory RegionLocationSizePurposeLVGL Frame BuffersPSRAM768 KBTwo full-frame buffers for double-buffered, tear-free rendering at 800x480x16bpp.LVGL Memory PoolPSRAM2 MBA dedicated heap for LVGL to create widgets, styles, and other graphical objects.Application HeapPSRAM1 MBA general-purpose heap for application-level data structures and buffers.System & RTOSInternal RAM~320 KBUsed for FreeRTOS kernel, task stacks, interrupt service routines, and critical real-time variables.This explicit partitioning of PSRAM is a key performance optimization. By pre-allocating large, contiguous blocks for the display buffers and LVGL's internal heap, the system guarantees that the UI will always have the memory it needs to function. This is enforced by the LVGL configuration (LV_MEM_CUSTOM = 1) and the manual allocation of buffers in the application's setup code. The remaining PSRAM and the fast internal RAM are then available for the application's own needs, creating a robust and predictable memory environment.5.0 Consolidated System Resource MapA comprehensive understanding of the system's resource allocation, particularly GPIO pins and I²C bus devices, is essential for stable operation and future expansion. This section provides a definitive map of all consumed and available resources.5.1 Master Pinout TableThe following table consolidates pinout information from the project's documentation, the Waveshare wiki, and schematic analysis. It serves as the single source of truth for all hardware connections and must be consulted before connecting any new peripherals.1GPIO #Primary FunctionComponent / InterfaceStatusNotes0G0Parallel RGB DisplayHardwiredBootstrapping pin. Affects boot mode. Do not use for other purposes.1G1Parallel RGB DisplayHardwiredBootstrapping pin.2G2Parallel RGB DisplayHardwiredBootstrapping pin.3VSYNCParallel RGB DisplayHardwiredVertical Sync timing signal.4TOUCH_IRQGT911 Touch ControllerConsumedInterrupt signal for touch events.5DEParallel RGB DisplayHardwiredData Enable timing signal.6B3Parallel RGB DisplayHardwired7PCLKParallel RGB DisplayHardwiredPixel Clock timing signal.8SDAI²C BusConsumedShared by GT911, CH422G, PCF85063A.9SCLI²C BusConsumedShared by GT911, CH422G, PCF85063A.10B4Parallel RGB DisplayHardwired11B5Parallel RGB DisplayHardwired12G7Parallel RGB DisplayHardwired13B0Parallel RGB DisplayHardwired14R0Parallel RGB DisplayHardwired15B7Parallel RGB DisplayHardwiredAlso used for DS18B20_PIN in project. Re-evaluate for conflict.16B6Parallel RGB DisplayHardwired17G5Parallel RGB DisplayHardwired18G6Parallel RGB DisplayHardwired19B1Parallel RGB DisplayHardwired20B2Parallel RGB DisplayHardwired21R1Parallel RGB DisplayHardwired33USER_GPIO_1User ApplicationAvailableGeneral purpose I/O.34USER_GPIO_2User ApplicationAvailableGeneral purpose I/O.35USER_GPIO_3User ApplicationAvailableGeneral purpose I/O (Input only on some ESP32s, check datasheet).36USER_GPIO_4User ApplicationAvailableGeneral purpose I/O (Input only on some ESP32s, check datasheet).37USER_GPIO_5User ApplicationAvailableGeneral purpose I/O (Input only on some ESP32s, check datasheet).38R5Parallel RGB DisplayHardwired39R6Parallel RGB DisplayHardwired40R7Parallel RGB DisplayHardwired41G4Parallel RGB DisplayHardwired42G3Parallel RGB DisplayHardwired43UART_TXUART0AvailableAvailable if USB CDC is used for console.44UART_RXUART0AvailableAvailable if USB CDC is used for console.45R4Parallel RGB DisplayHardwired46HSYNCParallel RGB DisplayHardwiredHorizontal Sync timing signal.47R2Parallel RGB DisplayHardwired48R3Parallel RGB DisplayHardwired-1DISPLAY_RSTCH422G I/O ExpanderConsumedControlled via I²C, not a direct GPIO.-1DISPLAY_BLCH422G I/O ExpanderConsumedControlled via I²C, not a direct GPIO.-1TOUCH_RSTCH422G I/O ExpanderConsumedControlled via I²C, not a direct GPIO.-1SD_CSCH422G I/O ExpanderConsumedControlled via I²C, not a direct GPIO.Note: The Readme.txt lists GPIO 15 as DS18B20_PIN, but the pinout table shows it is also hardwired to the display as B7. This is a direct conflict and must be resolved. The pin is likely unusable for 1-Wire, and an alternative "Available" pin must be selected for the temperature sensors.5.2 I²C Bus TopologyThe board utilizes a single I²C bus for multiple critical peripherals. This shared bus topology is efficient in terms of pin usage but requires careful software management to prevent communication conflicts.Bus Controller (Master): ESP32-S3Bus Pins:SDA (Serial Data): GPIO 8SCL (Serial Clock): GPIO 9Bus Peripherals (Slaves):GT911 Touch Controller: Address 0x5D or 0x14.8 Provides touch coordinates and events.CH422G I/O Expander: Address 0x71.3 Controls display reset, backlight, touch reset, and SD card CS.PCF85063A Real-Time Clock: Address 0x51.3 Provides timekeeping for logging and scheduling.Given that multiple tasks may need to access different devices on this shared bus (e.g., the touchTask reading from the GT911, the displayTask writing to the CH422G, and the loggingTask reading from the PCF85063A), all I²C transactions must be protected by a FreeRTOS mutex. This ensures that communication sequences are atomic and prevents one task from interrupting another's transaction, which could lead to corrupted data or bus lockups.6.0 Synthesis and AI-Actionable Development DirectivesThis final section synthesizes the preceding analysis into a set of direct, non-negotiable constraints and actionable development tasks. This information is designed to guide an AI assistant in contributing to the "Commercial Freezer Controller" project safely and effectively, without disturbing the fragile but functional core architecture.6.1 Immutable System Constraints & "Guard Rails" for AITo ensure system stability, all AI-assisted development must strictly adhere to the following rules. These are not guidelines; they are architectural imperatives derived from the hardware's physical design and the resulting software dependencies.Rule 1 (Library Management): DO NOT update, replace, or modify the libraries located in the project's local lib/ directory, specifically ESP32_Display_Panel@1.0.0 and ESP32_IO_Expander@1.0.1. Do not update the lvgl library beyond version 8.3.11. The project's compilation and runtime stability are critically dependent on this exact combination of library versions.Rule 2 (Initialization Protocol): All display-related initialization code MUST adhere to the mandatory, ordered sequence detailed in Section 3.2. All software control of the display's hardware reset and backlight functions MUST be performed exclusively through the API provided by the ESP32_IO_Expander library instance. Direct GPIO control is not possible and must not be attempted.Rule 3 (Resource Allocation): All new hardware peripherals must be connected only to GPIO pins designated as "Available" in the Master Pinout Table (Section 5.1). Do not reconfigure or repurpose any pin marked as "Consumed" or "Hardwired." The pin conflict identified on GPIO 15 must be resolved by selecting a different available pin for the DS18B20 1-Wire bus.Rule 4 (Task Architecture): New application-level tasks, such as network communication, complex calculations, or control of external hardware, SHOULD be created on and pinned to Core 1. Their FreeRTOS priority must be set lower than that of the UI tasks (LVGL_TASK_PRIORITY) to prevent introducing latency or stutter into the graphical interface.Rule 5 (Memory Management): Large data buffers or objects required by the application logic should be allocated from the designated "Application Heap" in PSRAM (app_heap) or allocated dynamically from the general PSRAM heap. This is to avoid memory fragmentation and to prevent the application from consuming memory that has been explicitly reserved for the high-performance graphics system.6.2 Target Areas for AI-Assisted ImplementationThe following are well-defined tasks that can be safely delegated to an AI assistant for implementation, operating within the established architectural framework.UI Development:Prompt: "Using the existing LVGL v8.3.11 framework and the globally available display driver object, develop the user interface screens for the freezer controller application. The UI must include:A 'Main Status' screen that displays temperature readings from four sensors, compressor status, and current time from the RTC.A 'Settings' screen that allows the user to adjust temperature setpoints and alarm thresholds using LVGL widgets like sliders or number pads.A 'Data Log' screen that displays timestamped temperature data in a scrollable list or table.All user input will be handled through the existing, initialized GT911 touch driver."Application Logic:Prompt: "Implement the primary freezer control logic within the controlTask function, which is pinned to Core 1 and runs on a 1000ms cycle. The logic should:Safely read the latest temperature data from the shared data structure populated by the sensorTask (ensure mutex protection).Compare the current temperatures against the user-defined setpoints.Implement a state machine for compressor control (e.g., ON, OFF, DEFROST_CYCLE) based on the temperature comparison and hysteresis values.Control the compressor and fan relays by toggling available GPIO pins (e.g., USER_GPIO_1, USER_GPIO_2)."Peripheral Integration (Temperature Sensors):Prompt: "Implement the sensorTask function, pinned to Core 1. This task should:Initialize the OneWire bus on a suitable, available GPIO pin (Note: GPIO 15 is conflicted, select an alternative like GPIO 33).Use the DallasTemperature library to discover and read temperatures from up to four DS18B20 sensors periodically (e.g., every 1000ms).Store the retrieved temperature readings in a global or shared data structure. Implement a FreeRTOS mutex to protect this data structure from race conditions when accessed by other tasks."Data Logging to SD Card:Prompt: "Implement the loggingTask function, pinned to Core 1 with a background priority. This task will run every 5000ms and perform the following actions:Read the current time from the PCF85063A RTC via the I²C bus.Read the latest temperature data from the shared sensor data structure (using mutex protection).Format this data into a CSV string (e.g., 'YYYY-MM-DD HH:MM:SS,temp1,temp2,temp3,temp4').Append this string to a log file on the Micro SD card.Crucially: All SD card operations must be implemented with the knowledge that the SD card's Chip Select (CS) pin is controlled by the CH422G expander on pin EXIO4. Before any SPI transaction to the SD card, use the ESP32_IO_Expander library API to set the CS pin LOW. After the transaction is complete, use the same API to set the CS pin HIGH."6.3 Guidelines for Safe System ExpansionShould the project require further hardware expansion, the following guidelines must be followed to maintain system integrity.Adding New I²C Devices: Additional I²C peripherals may be added to the shared bus on GPIO 8 and 9. It is imperative to ensure that the new device's slave address does not conflict with any existing device addresses: 0x5D (or 0x14), 0x71, and 0x51.Adding New SPI Devices: A new, independent SPI bus can be configured using the remaining available GPIOs. This is the recommended approach for any performance-sensitive SPI peripherals.Recommended Debugging Strategy: If the system boots to a black or corrupted screen, the fault is most likely in the initialization chain, not the application logic. The recommended debugging procedure is:Add serial print statements to the setup() function.First, verify that the I²C bus initialization completes.Second, run an I²C scanner function to confirm that a device is detected at address 0x71 (the CH422G).Third, confirm that the ESP32_IO_Expander library successfully initializes and that commands to toggle pins are sent without error.Only after confirming the I/O expander is functional should the ESP32_Display_Panel initialization be investigated. This structured approach directly follows the system's dependency hierarchy.